一：const int a;   int const a ;

这两个的作用是一样的，a都被定义成一个常整型数，一旦被定义后，就不能再其他地方重新赋值。

二：const int * a；

1：const修饰的是整型数 int，而不是指针，即a是一个指向常整型数的指针。近一步的理解为：整型数 *a是不可以被重新赋值的，而指针却是可以修改的，可以重新指向另外一个内存地址；

2：eg：

int a1=30; int a2=40;
const int *p=&a1;    //此时输出*p，结果为30
p=&a2;               //此时输出*p，结果为40
a2=80;               // 不能用*p=80来直接赋值，因为*p被const修饰，不能重新赋值
printf("%d\n",*p);   //此时输出*p，结果为80
三：int * const a；

1：const修饰的是指针a，而不是整型数*a，*a为变量而不是一个常量。即a是指向一个可以修改的整型数的常指针。进一步的理解为：指针指向的整型数是可以被修改的，但是指针不可以被修改。

2：eg：

int a1=30,int a2=40;
int * const p=&a1;     //此时输出*p的结果是 30
a1=80;                 // 可以用*p=80来代替，即可以用*pl来修改a1的值
 //p=&a2;   这句话是错误的，因为指针p被定义为一个常指针，不能再指向一个新的内存地址

 
printf("%d\n",*p);    //输出的结果是80
四：int const * a const;

a是指向一个常整型数的常指针，即指针不可修改，指针指向的整型数也是不可以被修改的。

五：总结

1：const离谁近，谁就不可以被修改

2：const在谁后面谁就不可以被修改，const在最前面的话则将其后移一位，其作用是等效的

3：即使不适用关键字const，也很容易写出功能正确的代码，那为什么还要如此看重关键字const呢？其原因在于关键字有其特殊的作用：它有可能产生更加紧凑的代码；它定义了一个常数，必然有其意义，可以向用户传递其特殊含义；合理使用关键字const，可以使编译器保护那些不希望被修改的参数，防止无意代码的修改，减少bug的产生。
